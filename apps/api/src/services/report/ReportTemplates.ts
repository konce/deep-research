// Report Templates System
// Provides different report templates for various research types

import type {
  ReportTemplate,
  ReportTemplateType,
  ReportMetadata,
  ReportStats,
} from './types';
import type { ReportSection, Citation } from '@deep-research/shared-types';

/**
 * Base Template Class
 * Provides common functionality for all templates
 */
abstract class BaseTemplate implements ReportTemplate {
  abstract name: ReportTemplateType;
  abstract displayName: string;
  abstract description: string;

  generateTitle(title: string, metadata?: ReportMetadata): string {
    let result = `# ${title}\n`;

    if (metadata?.generatedAt || !metadata) {
      const date = metadata?.generatedAt ? new Date(metadata.generatedAt) : new Date();
      result += `\n*Generated on ${date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })}*\n`;
    }

    return result;
  }

  generateSectionHeading(heading: string, level: number): string {
    const hashes = '#'.repeat(Math.min(level + 1, 6));
    return `${hashes} ${heading}`;
  }

  generateSectionContent(content: string): string {
    return content;
  }

  generateCitations(citations: Citation[], format: string = 'numbered'): string {
    let result = '## References\n\n';

    citations.forEach((citation, index) => {
      const number = index + 1;
      result += `${number}. **${citation.title}**`;

      if (citation.source) {
        result += `  \n   ${citation.source}`;
      }

      if (citation.url) {
        result += `  \n   [${citation.url}](${citation.url})`;
      }

      result += '\n\n';
    });

    return result;
  }
}

/**
 * Default Template
 * General-purpose report template
 */
class DefaultTemplate extends BaseTemplate {
  name: ReportTemplateType = 'default';
  displayName = 'Default Template';
  description = 'General-purpose research report template suitable for most topics';

  generateTOC(sections: ReportSection[]): string {
    let toc = '## Table of Contents\n\n';

    sections.forEach((section, index) => {
      const anchor = this.createAnchor(section.heading);
      toc += `${index + 1}. [${section.heading}](#${anchor})\n`;

      if (section.subsections && section.subsections.length > 0) {
        section.subsections.forEach((subsection, subIndex) => {
          const subAnchor = this.createAnchor(subsection.heading);
          toc += `   ${index + 1}.${subIndex + 1}. [${subsection.heading}](#${subAnchor})\n`;
        });
      }
    });

    return toc + '\n';
  }

  generateFooter(stats?: ReportStats): string {
    if (!stats) return '';

    let footer = '\n---\n\n';
    footer += `*Generated by Deep Research Agent â€¢ ${stats.wordCount.toLocaleString()} words â€¢ ${stats.citationCount} references*\n`;

    return footer;
  }

  private createAnchor(heading: string): string {
    return heading
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .trim();
  }
}

/**
 * Academic Template
 * Formal academic research paper template
 */
class AcademicTemplate extends BaseTemplate {
  name: ReportTemplateType = 'academic';
  displayName = 'Academic Template';
  description = 'Formal academic research paper format with structured sections';

  generateTitle(title: string, metadata?: ReportMetadata): string {
    let result = `# ${title}\n\n`;

    // Abstract section for academic papers
    result += `## Abstract\n\n`;
    result += `*This research report provides a comprehensive analysis of ${title.toLowerCase()}. `;
    result += `Generated through automated research and synthesis.*\n\n`;

    // Metadata
    if (metadata?.author) {
      result += `**Author**: ${metadata.author}\n\n`;
    }

    if (metadata?.generatedAt) {
      const date = new Date(metadata.generatedAt);
      result += `**Date**: ${date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })}\n\n`;
    }

    return result;
  }

  generateTOC(sections: ReportSection[]): string {
    let toc = '## Contents\n\n';

    sections.forEach((section, index) => {
      toc += `${index + 1}. ${section.heading}\n`;

      if (section.subsections && section.subsections.length > 0) {
        section.subsections.forEach((subsection, subIndex) => {
          toc += `   ${index + 1}.${subIndex + 1} ${subsection.heading}\n`;
        });
      }
    });

    toc += `${sections.length + 1}. References\n\n`;

    return toc;
  }

  generateCitations(citations: Citation[], format: string = 'apa'): string {
    let result = '## References\n\n';

    // Use APA-style citations for academic template
    citations.forEach((citation, index) => {
      const number = index + 1;
      const source = citation.source || 'Unknown Source';
      const year = new Date().getFullYear();

      result += `${number}. ${source}. (${year}). *${citation.title}*.`;

      if (citation.url) {
        result += ` Retrieved from ${citation.url}`;
      }

      result += '\n\n';
    });

    return result;
  }

  generateFooter(stats?: ReportStats): string {
    if (!stats) return '';

    let footer = '\n---\n\n';
    footer += '### Document Information\n\n';
    footer += `- **Word Count**: ${stats.wordCount.toLocaleString()}\n`;
    footer += `- **Sections**: ${stats.sectionCount}\n`;
    footer += `- **References**: ${stats.citationCount}\n`;

    if (stats.estimatedReadingTime) {
      footer += `- **Reading Time**: Approximately ${stats.estimatedReadingTime} minutes\n`;
    }

    footer += '\n*This document was generated using automated research methodology.*\n';

    return footer;
  }
}

/**
 * Technical Template
 * Technical documentation template with code-friendly formatting
 */
class TechnicalTemplate extends BaseTemplate {
  name: ReportTemplateType = 'technical';
  displayName = 'Technical Documentation';
  description = 'Technical documentation format optimized for code and technical content';

  generateTitle(title: string, metadata?: ReportMetadata): string {
    let result = `# ${title}\n\n`;

    // Technical docs header
    result += `> **Technical Research Report**\n\n`;

    // Badge-style metadata
    if (metadata?.version) {
      result += `![Version](https://img.shields.io/badge/version-${metadata.version}-blue)\n`;
    }

    result += `![Status](https://img.shields.io/badge/status-research-green)\n`;
    result += `![Generated](https://img.shields.io/badge/generated-${new Date().toISOString().split('T')[0]}-lightgrey)\n\n`;

    return result;
  }

  generateTOC(sections: ReportSection[]): string {
    let toc = '## ðŸ“‘ Table of Contents\n\n';

    sections.forEach((section, index) => {
      const anchor = this.createAnchor(section.heading);
      const emoji = this.getSectionEmoji(section.heading);
      toc += `${index + 1}. ${emoji} [${section.heading}](#${anchor})\n`;

      if (section.subsections && section.subsections.length > 0) {
        section.subsections.forEach((subsection, subIndex) => {
          const subAnchor = this.createAnchor(subsection.heading);
          toc += `   - [${subsection.heading}](#${subAnchor})\n`;
        });
      }
    });

    return toc + '\n';
  }

  generateSectionHeading(heading: string, level: number): string {
    const hashes = '#'.repeat(Math.min(level + 1, 6));
    const emoji = this.getSectionEmoji(heading);
    return `${hashes} ${emoji} ${heading}`;
  }

  generateCitations(citations: Citation[], format: string = 'numbered'): string {
    let result = '## ðŸ“š References\n\n';

    citations.forEach((citation, index) => {
      const number = index + 1;
      result += `**[${number}]** ${citation.title}`;

      if (citation.source) {
        result += ` - *${citation.source}*`;
      }

      if (citation.url) {
        result += `\n  - ðŸ”— [${citation.url}](${citation.url})`;
      }

      result += '\n\n';
    });

    return result;
  }

  generateFooter(stats?: ReportStats): string {
    if (!stats) return '';

    let footer = '\n---\n\n';
    footer += '## ðŸ“Š Statistics\n\n';
    footer += `| Metric | Value |\n`;
    footer += `|--------|-------|\n`;
    footer += `| Words | ${stats.wordCount.toLocaleString()} |\n`;
    footer += `| Sections | ${stats.sectionCount} |\n`;
    footer += `| Subsections | ${stats.subsectionCount} |\n`;
    footer += `| References | ${stats.citationCount} |\n`;

    if (stats.estimatedReadingTime) {
      footer += `| Est. Reading Time | ${stats.estimatedReadingTime} min |\n`;
    }

    footer += '\n---\n\n';
    footer += '*Generated by Deep Research Agent* ðŸ¤–\n';

    return footer;
  }

  private createAnchor(heading: string): string {
    return heading
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .trim();
  }

  private getSectionEmoji(heading: string): string {
    const lower = heading.toLowerCase();

    if (lower.includes('introduction') || lower.includes('overview')) return 'ðŸ“–';
    if (lower.includes('feature') || lower.includes('capability')) return 'âš¡';
    if (lower.includes('architecture') || lower.includes('design')) return 'ðŸ—ï¸';
    if (lower.includes('implement') || lower.includes('usage')) return 'ðŸ’»';
    if (lower.includes('example') || lower.includes('demo')) return 'ðŸ”';
    if (lower.includes('conclusion') || lower.includes('summary')) return 'ðŸŽ¯';
    if (lower.includes('performance') || lower.includes('benchmark')) return 'ðŸ“Š';
    if (lower.includes('security') || lower.includes('privacy')) return 'ðŸ”’';

    return 'ðŸ“Œ';
  }
}

/**
 * Executive Template
 * Executive summary focused template for business/management audience
 */
class ExecutiveTemplate extends BaseTemplate {
  name: ReportTemplateType = 'executive';
  displayName = 'Executive Summary';
  description = 'Concise executive summary format focused on key insights and actionable items';

  generateTitle(title: string, metadata?: ReportMetadata): string {
    let result = `# ${title}\n`;
    result += `## Executive Summary\n\n`;

    if (metadata?.generatedAt) {
      const date = new Date(metadata.generatedAt);
      result += `**Date**: ${date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })}\n\n`;
    }

    return result;
  }

  generateTOC(sections: ReportSection[]): string {
    // Executive summaries typically don't need TOC
    return '---\n\n';
  }

  generateSectionHeading(heading: string, level: number): string {
    // Use bold headings for executive template
    if (level === 1) {
      return `## ${heading}`;
    } else {
      return `### ${heading}`;
    }
  }

  generateSectionContent(content: string): string {
    // For executive template, keep content concise
    return content;
  }

  generateCitations(citations: Citation[], format: string = 'numbered'): string {
    let result = '## Sources\n\n';

    // Simplified citations for executive summary
    citations.forEach((citation, index) => {
      result += `${index + 1}. ${citation.title}`;

      if (citation.url) {
        result += ` - [Link](${citation.url})`;
      }

      result += '\n';
    });

    return result + '\n';
  }

  generateFooter(stats?: ReportStats): string {
    if (!stats) return '';

    let footer = '\n---\n\n';
    footer += `*${stats.citationCount} sources â€¢ ${stats.wordCount.toLocaleString()} words`;

    if (stats.estimatedReadingTime) {
      footer += ` â€¢ ${stats.estimatedReadingTime} min read`;
    }

    footer += '*\n';

    return footer;
  }
}

/**
 * Template Registry
 * Manages available report templates
 */
class TemplateRegistry {
  private templates: Map<ReportTemplateType, ReportTemplate>;

  constructor() {
    this.templates = new Map();

    // Register default templates
    this.register(new DefaultTemplate());
    this.register(new AcademicTemplate());
    this.register(new TechnicalTemplate());
    this.register(new ExecutiveTemplate());
  }

  /**
   * Register a new template
   */
  register(template: ReportTemplate): void {
    this.templates.set(template.name, template);
  }

  /**
   * Get template by name
   */
  get(name: ReportTemplateType): ReportTemplate {
    const template = this.templates.get(name);

    if (!template) {
      console.warn(`Template "${name}" not found, using default`);
      return this.templates.get('default')!;
    }

    return template;
  }

  /**
   * Get all available templates
   */
  getAll(): ReportTemplate[] {
    return Array.from(this.templates.values());
  }

  /**
   * Get template names
   */
  getNames(): ReportTemplateType[] {
    return Array.from(this.templates.keys());
  }

  /**
   * Check if template exists
   */
  has(name: ReportTemplateType): boolean {
    return this.templates.has(name);
  }
}

// Singleton registry instance
let registry: TemplateRegistry | null = null;

/**
 * Get template registry singleton
 */
export function getTemplateRegistry(): TemplateRegistry {
  if (!registry) {
    registry = new TemplateRegistry();
    console.log('[ReportTemplates] Template registry initialized');
  }
  return registry;
}

/**
 * Get template by name (convenience function)
 */
export function getTemplate(name: ReportTemplateType = 'default'): ReportTemplate {
  return getTemplateRegistry().get(name);
}

/**
 * Get all available templates
 */
export function getAllTemplates(): ReportTemplate[] {
  return getTemplateRegistry().getAll();
}
